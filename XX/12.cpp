/*
The sequence of triangle numbers is generated by adding the natural numbers. So the
7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
*/

int getNextTriangleNum(int, int);
int getTotalFactors(int);

#include <iostream>
#include <vector>

int main()
{
  const int LIMIT = 500;

  int
    index = 0,
    lastTriangleNum = 0;

  while(true)
  {
    lastTriangleNum = getNextTriangleNum(index, lastTriangleNum);
    index++;

    if(getTotalFactors(lastTriangleNum) > LIMIT)
    {
      break;
    }
  }

  std::cout << "The first triangle number to have over "<< LIMIT << " divisors is: " << lastTriangleNum << std::endl;
  return 0;
}

int getNextTriangleNum(int index, int lastTriangleNum)
{
  index++;
  return (index + lastTriangleNum);
}

int getTotalFactors(int num)
{
  /*
   * Total number of factors of any number can be calculated as follows:
   * Ex. we have a number 28. It can be broken down as:

   * 28 = 2 * 14 = 2 * 2 * 7
   *             = (2 ^ 2) * (7 ^ 1)

   * Next, raise the exponents each by 1 ie. (2 + 1) and (1 + 1).

   * Total numbers of factors is the multiple of the above results ie. 3 * 2 = 6.
  */

  std::vector<int>Composition;

  /* Fill the vector by the its individual multiplying composition */
  for(int i = 2; i <= num;)
  {
    if(num % i == 0)
    {
      Composition.push_back(i);
      num /= i;
    }
    else
    {
      i++;
    }
  }

  /* Calculate the exponents */
  std::vector<int>Exponents;

  for(int i = 0; i < Composition.size(); i++)
  {

    int count;

    // Initialize count to 1 if element is not 0.
    if(Composition[i] != 0)
    {
      count = 1;
    }
    else
    {
      count = 0;
    }

    for(int j = i + 1; j < Composition.size(); j++)
    {
      if(Composition[i] == Composition[j] && Composition[i] != 0)
      {
        Composition[j] = 0;
        count++;
      }
    }
    
    Exponents.push_back(count);
  }

  /* Add the exponents each by 1 */
  for(int i = 0; i < Exponents.size(); i++)
  {
    Exponents[i] += 1;
  }

  /* Multiply the exponents */
  int totalFactors = 1;

  for(int i = 0; i < Exponents.size(); i++)
  {
    totalFactors *= Exponents[i];
  }

  return totalFactors;
}